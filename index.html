<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Analizador de Gramaticas</title>
  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* small safety for fonts and body */
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  </style>
</head>
<body class="bg-blue-50">
  <div id="root"></div>

  <!-- React and ReactDOM (UMD builds) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for in-browser JSX transpilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- App script (JSX) -->
  <script type="text/babel">
  const { useState } = React;

  /* Simple SVG icon replacements for lucide-react icons used in the component */
  const AlertCircle = ({ size=24, className="" }) => (
    <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
      <circle cx="12" cy="12" r="10" strokeWidth="2"></circle>
      <path d="M12 8v4" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"></path>
      <path d="M12 16h.01" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"></path>
    </svg>
  );
  const CheckCircle = ({ size=24, className="" }) => (
    <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
      <path d="M9 12l2 2 4-4" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"></path>
      <circle cx="12" cy="12" r="10" strokeWidth="2"></circle>
    </svg>
  );
  const ChevronRight = ({ size=20, className="" }) => (
    <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
      <path d="M9 6l6 6-6 6" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"></path>
    </svg>
  );

  // Begin ParserAnalyzer component
  function ParserAnalyzer() {
    const [parserType, setParserType] = useState("LL1");
    const [grammarText, setGrammarText] = useState("");
    const [inputString, setInputString] = useState("");
    const [results, setResults] = useState(null);
    const [error, setError] = useState("");

    const tokenizeProduction = (prod) => {
      // S√≠mbolo separado por espacios
      if (!prod) return [];
      if (prod.includes(" ")) {
        return prod.split(/\s+/).filter(Boolean);
      }
      const tokens = [];
      let i = 0;
      while (i < prod.length) {
        // Analizar car√°cter por car√°cter
        const ch = prod[i];
        if (ch === " ") { i++; continue; }
        if (/[A-Z]/.test(ch)) { tokens.push(ch); i++; continue; }
        if (/[a-z0-9_]/.test(ch) || ch === "+" || ch === "-" || ch === "*") {
          let tok = "";
          while (i < prod.length && /[a-z0-9_+\-*]/.test(prod[i])) {
            tok += prod[i];
            i++;
          }
          tokens.push(tok);
          continue;
        }
        tokens.push(ch);
        i++;
      }
      return tokens;
    };

    const parseGrammar = (text) => {
      // Dividir el texto en l√≠neas, inicializar y crear la variable del s√≠mbolo inicial
      const lines = text.split("\n");
      const grammar = {};
      let startSymbol = null;
      for (let raw of lines) {
        // Eliminar espacios y comentarios
        const line = raw.trim();
        if (!line || line.startsWith("#")) continue;
        // Dividir en LHS y RHS
        const arrowIndex = line.indexOf("->");
        if (arrowIndex === -1) continue;
        const lhs = line.slice(0, arrowIndex).trim();
        const rhs = line.slice(arrowIndex + 2).trim();
        // Establecer el s√≠mbolo inicial
        if (!startSymbol) startSymbol = lhs;
        // Dividir RHS en alternativas con el s√≠mbolo '|'
        const alternatives = rhs.split("|").map((s) => s.trim());
        grammar[lhs] = grammar[lhs] || [];
        // Procesar las producciones
        for (const alt of alternatives) {
          // Con epsilon
          if (alt === "Œµ" || alt === "" || alt === "eps") {
            grammar[lhs].push(["Œµ"]);
          } else {
            // Tokenizar producci√≥n
            grammar[lhs].push(tokenizeProduction(alt));
          }
        }
      }
      // Devuelve un objeto con la gram√°tica legible por la computadora y el s√≠mbolo inicial
      return { grammar, startSymbol };
    };

    const getAllSymbols = (grammar) => {
      // Identificar terminales y no terminales
      const nonTerminals = new Set(Object.keys(grammar)); //Identificar no terminales
      const terminals = new Set(); // Identificar terminales
      for (const prods of Object.values(grammar)) {
        for (const prod of prods) {
          if (prod.length === 1 && prod[0] === "Œµ") continue; //Ignorar Epsilon
          for (const token of prod) {
            if (!nonTerminals.has(token) && token !== "Œµ") terminals.add(token);
          }
        }
      }
      return { terminals: Array.from(terminals), nonTerminals: Array.from(nonTerminals) };
    };

    const computeFirst = (grammar) => {
      // Inicializaci√≥n de conjuntos First
      const first = {};
      const { terminals, nonTerminals } = getAllSymbols(grammar); // Identificar terminales y no terminales
      terminals.forEach((t) => { first[t] = new Set([t]); }); // Regla para terminales
      Object.keys(grammar).forEach((nt) => { first[nt] = new Set(); }); // Inicializar no terminales
      // Iterativamente aplicar reglas de First hasta que no haya cambios
      let changed = true; let iterations = 0;
      while (changed && iterations < 1000) {
        changed = false; iterations++;
        for (const [nt, prods] of Object.entries(grammar)) {
          for (const prod of prods) {
            // Procesar las producciones epsilon
            if (prod.length === 1 && prod[0] === "Œµ") {
              if (!first[nt].has("Œµ")) { first[nt].add("Œµ"); changed = true; }
              continue;
            }
            // Procesar producciones normales
            let nullablePrefix = true;
            for (const symbol of prod) {
              const symbolFirst = first[symbol] || new Set([symbol]);
              for (const s of symbolFirst) {
                if (s !== "Œµ" && !first[nt].has(s)) {
                  first[nt].add(s);
                  changed = true;
                }
              }
              if (!symbolFirst.has("Œµ")) { nullablePrefix = false; break; }
            }
            if (nullablePrefix) {
              if (!first[nt].has("Œµ")) { first[nt].add("Œµ"); changed = true; }
            }
          }
        }
      }
      return first;
    };

    const computeFollow = (grammar, startSymbol) => {
      // Inicializaci√≥n de conjuntos Follow
      const follow = {};
      const nonTerminals = Object.keys(grammar); // Identificar no terminales
      nonTerminals.forEach((nt) => (follow[nt] = new Set())); // Inicializar no terminales
      if (follow[startSymbol]) follow[startSymbol].add("$"); // Regla para el s√≠mbolo inicial
      const first = computeFirst(grammar); // Calcular conjuntos First
      // Iterativamente aplicar reglas de Follow hasta que no haya cambios
      let changed = true; let iterations = 0;
      while (changed && iterations < 1000) {
        changed = false; iterations++;
        // Para cada producci√≥n A -> Œ±BŒ≤
        for (const [lhs, prods] of Object.entries(grammar)) {
          for (const prod of prods) {
            // Para cada s√≠mbolo B en la producci√≥n 
            for (let i = 0; i < prod.length; i++) {
              const B = prod[i];
              if (!grammar[B]) continue;
              // Calcular First(Œ≤)
              const beta = prod.slice(i + 1);
              const firstBeta = new Set();
              let allNullable = true;
              if (beta.length === 0) allNullable = true;
              else {
                for (const sym of beta) {
                  const symFirst = first[sym] || new Set([sym]);
                  for (const t of symFirst) if (t !== "Œµ") firstBeta.add(t);
                  if (!symFirst.has("Œµ")) { allNullable = false; break; }
                }
              }
              // Reglas de Follow
              const beforeSize = follow[B].size;
              firstBeta.forEach((t) => follow[B].add(t)); // Follow(B) = First(Œ≤)-{Œµ}
              if (allNullable) { follow[lhs].forEach((t) => follow[B].add(t)); } // Follow(B) = Follow(A)
              if (follow[B].size > beforeSize) changed = true;
            }
          }
        }
      }
      return follow;
    };

    const buildLL1Table = (grammar, firstSets, followSets) => {
      // Inicializaci√≥n de la tabla y creaci√≥n
      const table = {};
      const { terminals, nonTerminals } = getAllSymbols(grammar);
      const termSet = new Set(terminals.concat(["$"]));
      const conflicts = [];
      nonTerminals.forEach((nt) => {
        table[nt] = {}; termSet.forEach((t) => (table[nt][t] = []));
      });
      // Para cada producci√≥n A -> Œ± (procesamiento)
      for (const [A, prods] of Object.entries(grammar)) {
        // Calcular el first(Œ±)
        for (const prod of prods) {
          const firstProd = new Set();
          if (prod.length === 1 && prod[0] === "Œµ") firstProd.add("Œµ");
          else {
            let nullablePrefix = true;
            for (const sym of prod) {
              const symFirst = firstSets[sym] || new Set([sym]);
              symFirst.forEach((s) => { if (s !== "Œµ") firstProd.add(s); });
              if (!symFirst.has("Œµ")) { nullablePrefix = false; break; }
            }
            if (nullablePrefix) firstProd.add("Œµ");
          }
          // Llenar la tabla LL(1)
          for (const t of firstProd) {
            if (t === "Œµ") { // Para producciones epsilon
              for (const b of (followSets[A] || [])) {
                if (table[A][b].length > 0) conflicts.push(`Conflicto en [${A}, ${b}]`);
                table[A][b].push(prod);
              }
            } else { // Para terminales en first(Œ±)
              if (table[A][t].length > 0) conflicts.push(`Conflicto en [${A}, ${t}]`);
              table[A][t].push(prod);
            }
          }
        }
      }
      return { table, terminals: Array.from(termSet), conflicts };
    };

    const tokenizeInput = (input) => {
      if (!input) return [];
      if (input.includes(" ")) return input.split(/\s+/).filter(Boolean);
      return tokenizeProduction(input);
    };

    const parseLL1 = (grammar, table, terminals, inputTokens, startSymbol) => {
      // Inicializaci√≥n
      const stack = ["$"].concat([startSymbol]);
      const input = inputTokens.concat(["$"]);
      let ip = 0;
      const steps = [];
      while (stack.length > 0) {
        const top = stack[stack.length - 1]; // Tope de la pila
        const curr = input[ip]; // S√≠mbolo actual de entrada
        // Registrar los pasos
        steps.push({ stack: [...stack].slice().reverse().join(" "), input: input.slice(ip).join(" "), action: "" });
        // Tres Casos Posibles
        // Caso 1: Match de terminal
        if (top === curr) {
          if (top === "$") { steps[steps.length - 1].action = "Aceptar"; return { success: true, steps }; }
          stack.pop(); ip++; steps[steps.length - 1].action = `Match ${top}`;
        } else if (!grammar[top]) { // Caso 2: Error de terminal inesperado
          return { success: false, steps, error: `Error: esperaba ${top}, encontr√≥ ${curr}` };
        } else { // Caso 3: No terminal, aplicar producci√≥n
          const prods = table[top] && table[top][curr] ? table[top][curr] : [];
          if (!prods || prods.length === 0) return { success: false, steps, error: `Error: no hay producci√≥n para [${top}, ${curr}]` };
          const prod = prods[0];
          steps[steps.length - 1].action = `${top} ‚Üí ${prod.length === 1 && prod[0] === "Œµ" ? "Œµ" : prod.join(" ")}`;
          stack.pop();
          if (!(prod.length === 1 && prod[0] === "Œµ")) {
            for (let i = prod.length - 1; i >= 0; i--) stack.push(prod[i]);
          }
        }
        if (steps.length > 2000) return { success: false, steps, error: "Error: demasiados pasos" };
      }
      return { success: false, steps, error: "Error inesperado" };
    };

    const buildLR0Items = (grammar, startSymbol) => {
      // Construcci√≥n de conjuntos de √≠tems LR(0)
      const augmentedStart = `${startSymbol}'`; // Crea la gram√°tica aumentada
      const augmentedGrammar = { ...grammar };
      augmentedGrammar[augmentedStart] = [[startSymbol]];
      const itemToStr = (it) => `${it.lhs}‚Üí${it.rhs.join(" ")}¬∑${it.dot}`;
      // Encontrar todos los √≠tems derivados de un conjunto inicial
      const closure = (items) => {
        const res = new Map();
        const queue = items.map((it) => ({ ...it }));
        for (const it of queue) res.set(itemToStr(it), it);
        while (queue.length) {
          const item = queue.shift();
          if (item.dot < item.rhs.length) {
            const B = item.rhs[item.dot];
            if (augmentedGrammar[B]) {
              for (const prod of augmentedGrammar[B]) {
                const newItem = { lhs: B, rhs: prod, dot: 0 };
                const key = itemToStr(newItem);
                if (!res.has(key)) { res.set(key, newItem); queue.push(newItem); }
              }
            }
          }
        }
        return Array.from(res.values());
      };
      // Calcular el conjunto de √≠tems despu√©s de reconocer el s√≠mbolo X.
      const gotoFunc = (items, X) => {
        const moved = [];
        for (const it of items) {
          if (it.dot < it.rhs.length && it.rhs[it.dot] === X) {
            moved.push({ lhs: it.lhs, rhs: it.rhs, dot: it.dot + 1 });
          }
        }
        return closure(moved);
      };
      // Comparar dos conjuntos de √≠tems para saber si est√°n duplicados
      const itemsEqual = (a, b) => {
        if (a.length !== b.length) return false;
        const sa = new Set(a.map(itemToStr));
        const sb = new Set(b.map(itemToStr));
        for (const x of sa) if (!sb.has(x)) return false;
        return true;
      };
      // Construcci√≥n de los estados y transiciones (aut√≥mata)
      const I0 = closure([{ lhs: augmentedStart, rhs: [startSymbol], dot: 0 }]);
      const states = [I0];
      const transitions = {};
      let idx = 0;
      while (idx < states.length) {
        const state = states[idx];
        const symbols = new Set();
        // Recolectar todos los s√≠mbolos despu√©s del punto
        state.forEach((it) => {
          if (it.dot < it.rhs.length) symbols.add(it.rhs[it.dot]);
        });
        // Para cada s√≠mbolo, calcular GOTO
        for (const X of symbols) {
          const g = gotoFunc(state, X);
          if (g.length === 0) continue;
          // Buscar si este estado ya existe
          let found = -1;
          for (let s = 0; s < states.length; s++) if (itemsEqual(states[s], g)) { found = s; break; }
          // Si no existe, agregarlo
          if (found === -1) { found = states.length; states.push(g); } 
          transitions[`${idx},${X}`] = found; // Registrar transici√≥n
        }
        idx++;
      }
      return { states, transitions, augmentedGrammar, augmentedStart };
    };

    const buildSLR1Table = (grammar, startSymbol) => {
      const { states, transitions, augmentedGrammar, augmentedStart } = buildLR0Items(grammar, startSymbol);
      const followSets = computeFollow(grammar, startSymbol);
      const { terminals, nonTerminals } = getAllSymbols(grammar);
      const termSet = new Set(terminals.concat(["$"]));
      const action = {}, gotoTable = {}, conflicts = [];
      states.forEach((st, i) => {
        action[i] = {}; gotoTable[i] = {};
        termSet.forEach((t) => (action[i][t] = []));
        nonTerminals.forEach((nt) => (gotoTable[i][nt] = null));
        for (const item of st) {
          if (item.dot < item.rhs.length) {
            const a = item.rhs[item.dot];
            const key = `${i},${a}`;
            if (transitions[key] !== undefined) {
              const t = transitions[key];
              if (!grammar[a]) {
                const shift = `s${t}`;
                if (!action[i][a].includes(shift)) action[i][a].push(shift);
              } else {
                gotoTable[i][a] = transitions[key];
              }
            }
          } else {
            if (item.lhs === augmentedStart) {
              action[i]["$"] = ["acc"];
            } else {
              const prodRhs = item.rhs.length === 0 ? ["Œµ"] : item.rhs;
              const reduce = `r${item.lhs}‚Üí${prodRhs.join(" ")}`;
              (followSets[item.lhs] || new Set()).forEach((a) => {
                if (!action[i][a].includes(reduce)) action[i][a].push(reduce);
              });
            }
          }
        }
      });
      return { action, gotoTable, terminals: Array.from(termSet), nonTerminals, conflicts, states };
    };

    const parseSLR1 = (grammar, action, gotoTable, inputTokens) => {
      // Inicializaci√≥n
      const stack = [0]; // Pila de estados, con 0 inicialmente
      const input = inputTokens.concat(["$"]); // Cadena de entrada con s√≠mbolo de fin
      let ip = 0; // Puntero de entrada
      const steps = []; // Registro de pasos
      // Bucle principal del an√°lisis que se ejecuta hasta aceptaci√≥n o error
      while (true) {
        const state = stack[stack.length - 1]; // Estado actual
        const a = input[ip]; // S√≠mbolo actual de entrada
        // Registrar el paso actual
        steps.push({ stack: stack.join(" "), input: input.slice(ip).join(" "), action: "" });
        const acts = action[state] && action[state][a] ? action[state][a] : [];
        // Error si no hay acci√≥n definida
        if (!acts || acts.length === 0) {
          return { success: false, steps, error: `Error: no hay acci√≥n para estado ${state} con s√≠mbolo '${a}'` };
        }
        const act = acts[0];
        // Caso 1: Aceptar
        if (act === "acc") { steps[steps.length - 1].action = "Aceptar"; return { success: true, steps }; }
        // Caso 2: Desplazar (Shift)
        if (act.startsWith("s")) {
          const ns = parseInt(act.slice(1), 10);
          steps[steps.length - 1].action = `Shift ${ns}`;
          stack.push(ns); ip++;
        // Caso 3: Reducir (Reduce)
        } else if (act.startsWith("r")) {
          const prodText = act.slice(1);
          const arrow = prodText.indexOf("‚Üí");
          const lhs = prodText.slice(0, arrow);
          const rhs = prodText.slice(arrow + 1).trim();
          const rhsTokens = rhs === "Œµ" || rhs === "" ? [] : rhs.split(/\s+/).filter(Boolean);
          steps[steps.length - 1].action = `Reduce ${lhs} ‚Üí ${rhsTokens.length === 0 ? "Œµ" : rhsTokens.join(" ")}`;
          for (let k = 0; k < rhsTokens.length; k++) stack.pop(); // Desapilar estados
          // Consultar la tabla GOTO para el nuevo estado
          const prev = stack[stack.length - 1];
          const next = gotoTable[prev] && gotoTable[prev][lhs] !== null ? gotoTable[prev][lhs] : null;
          if (next === null) return { success: false, steps, error: `Error: no hay goto para estado ${prev} y s√≠mbolo ${lhs}` };
          stack.push(next); // Apilar el nuevo estado
        }
        if (steps.length > 2000) return { success: false, steps, error: "Error: demasiados pasos" };
      }
    };

    const analyzeGrammar = () => {
      try {
        // Validaci√≥n y manejo de errores
        setError(""); setResults(null);
        if (!grammarText.trim()) { setError("Por favor ingresa una gram√°tica"); return; }
        const { grammar, startSymbol } = parseGrammar(grammarText);
        if (!startSymbol || Object.keys(grammar).length === 0) { setError("Gram√°tica inv√°lida. Formato: S -> a S | b"); return; }
        // Calcular los conjuntos First y Follow
        const firstSets = computeFirst(grammar);
        const followSets = computeFollow(grammar, startSymbol);
        // Construir la tabla y analizar seg√∫n el tipo de parser seleccionado
        // Si es LL(1)
        if (parserType === "LL1") {
          const { table, terminals, conflicts } = buildLL1Table(grammar, firstSets, followSets);
          if (conflicts.length > 0) { setError(`Gram√°tica NO es LL(1). ${conflicts.join(", ")}`); setResults({ isValid: false, firstSets, followSets, conflicts }); return; }
          let parseResult = null;
          if (inputString.trim()) {
            const inputTokens = tokenizeInput(inputString.trim());
            parseResult = parseLL1(grammar, table, terminals, inputTokens, startSymbol);
          }
          setResults({ isValid: true, firstSets, followSets, table, terminals, startSymbol, parseResult });
        } else { // Si es SLR(1)
          const { action, gotoTable, terminals, nonTerminals, conflicts, states } = buildSLR1Table(grammar, startSymbol);
          if (conflicts.length > 0) { setError(`Gram√°tica NO es SLR(1). ${conflicts.join(", ")}`); setResults({ isValid: false, firstSets, followSets, conflicts }); return; }
          let parseResult = null;
          if (inputString.trim()) {
            const inputTokens = tokenizeInput(inputString.trim());
            parseResult = parseSLR1(grammar, action, gotoTable, inputTokens);
          }
          setResults({ isValid: true, firstSets, followSets, action, gotoTable, terminals, nonTerminals, startSymbol, parseResult, states });
        }
      } catch (err) {
        console.error(err); setError(`Error: ${err.message}`);
      }
    };

    return (
      <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-blue-100 p-6">
        <div className="max-w-7xl mx-auto">
          <div className="text-center mb-8">
            <h1 className="text-5xl font-bold text-blue-900 mb-2">
              Analizador de Gram√°ticas
            </h1>
            <p className="text-blue-600 text-lg">LL(1) y SLR(1) Parser Generator</p>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <div className="bg-white rounded-2xl p-6 border-2 border-blue-200 shadow-lg">
              <label className="block text-blue-900 font-semibold mb-3 text-lg">Tipo de Parser</label>
              <div className="flex gap-4">
                <button onClick={() => setParserType("LL1")} className={"flex-1 py-3 px-6 rounded-xl font-semibold transition-all " + (parserType === "LL1" ? "bg-blue-500 text-white shadow-md scale-105" : "bg-blue-50 text-blue-600 hover:bg-blue-100 border-2 border-blue-200")}>LL(1)</button>
                <button onClick={() => setParserType("SLR1")} className={"flex-1 py-3 px-6 rounded-xl font-semibold transition-all " + (parserType === "SLR1" ? "bg-blue-500 text-white shadow-md scale-105" : "bg-blue-50 text-blue-600 hover:bg-blue-100 border-2 border-blue-200")}>SLR(1)</button>
              </div>
            </div>

            <div className="bg-white rounded-2xl p-6 border-2 border-blue-200 shadow-lg">
              <label className="block text-blue-900 font-semibold mb-3 text-lg">Cadena de Entrada</label>
              <input type="text" value={inputString} onChange={(e) => setInputString(e.target.value)} placeholder="Ej: a a b b  (o: aabb)" className="w-full p-3 rounded-xl bg-blue-50 border-2 border-blue-200 text-blue-900 placeholder-blue-400 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400" />
            </div>
          </div>

          <div className="bg-white rounded-2xl p-6 border-2 border-blue-200 shadow-lg mb-6">
            <label className="block text-blue-900 font-semibold mb-3 text-lg">Gram√°tica</label>
            <textarea value={grammarText} onChange={(e) => setGrammarText(e.target.value)} placeholder={'Formato: S -> a S | b\nA -> a A | Œµ\n\n- Puedes separar tokens por espacios para s√≠mbolos multi-car√°cter\n- Usa "Œµ" para epsilon'} rows={8} className="w-full p-4 rounded-xl bg-blue-50 border-2 border-blue-200 text-blue-900 placeholder-blue-400 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400 font-mono"></textarea>
            <button onClick={analyzeGrammar} className="mt-4 w-full bg-blue-500 text-white py-3 px-6 rounded-xl font-semibold hover:bg-blue-600 transition-all shadow-md hover:shadow-lg flex items-center justify-center gap-2">
              Analizar Gram√°tica <ChevronRight size={20} />
            </button>
          </div>

          {error && (
            <div className="bg-red-50 border-2 border-red-300 rounded-2xl p-6 mb-6 flex items-start gap-3">
              <AlertCircle className="text-red-500 flex-shrink-0 mt-1" size={24} />
              <p className="text-red-700 font-semibold">{error}</p>
            </div>
          )}

          {results && (
            <div className="space-y-6">
              {results.isValid && (
                <div className="bg-green-50 border-2 border-green-300 rounded-2xl p-6 flex items-center gap-3">
                  <CheckCircle className="text-green-600" size={24} />
                  <p className="text-green-700 font-semibold">‚úì La gram√°tica es {parserType}</p>
                </div>
              )}

              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="bg-white rounded-2xl p-6 border-2 border-blue-200 shadow-lg">
                  <h3 className="text-xl font-bold text-blue-900 mb-4 flex items-center gap-2">üìä Conjuntos First</h3>
                  <div className="space-y-2">
                    {Object.entries(results.firstSets).map(([symbol, set]) => (
                      <div key={symbol} className="bg-blue-50 rounded-lg p-3 border border-blue-100">
                        <span className="text-blue-600 font-semibold">First({symbol}):</span>
                        <span className="text-blue-900 ml-2">{Array.from(set).join(", ")}</span>
                      </div>
                    ))}
                  </div>
                </div>

                <div className="bg-white rounded-2xl p-6 border-2 border-blue-200 shadow-lg">
                  <h3 className="text-xl font-bold text-blue-900 mb-4 flex items-center gap-2">üìã Conjuntos Follow</h3>
                  <div className="space-y-2">
                    {Object.entries(results.followSets).map(([symbol, set]) => (
                      <div key={symbol} className="bg-blue-50 rounded-lg p-3 border border-blue-100">
                        <span className="text-blue-600 font-semibold">Follow({symbol}):</span>
                        <span className="text-blue-900 ml-2">{Array.from(set).join(", ")}</span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>

              {results.isValid && results.table && (
                <div className="bg-white rounded-2xl p-6 border-2 border-blue-200 shadow-lg overflow-x-auto">
                  <h3 className="text-xl font-bold text-blue-900 mb-4">Tabla de An√°lisis LL(1)</h3>
                  <div className="overflow-x-auto">
                    <table className="w-full text-sm">
                      <thead>
                        <tr className="border-b-2 border-blue-300">
                          <th className="p-2 text-blue-700 font-semibold text-left">No Terminal</th>
                          {results.terminals.map((t) => (<th key={t} className="p-2 text-blue-700 font-semibold">{t}</th>))}
                        </tr>
                      </thead>
                      <tbody>
                        {Object.entries(results.table).map(([nt, row]) => (
                          <tr key={nt} className="border-b border-blue-200">
                            <td className="p-2 text-blue-900 font-semibold">{nt}</td>
                            {results.terminals.map((t) => (
                              <td key={t} className="p-2 text-center">
                                <span className="text-blue-600">{row[t] && row[t].length > 0 ? `${nt}‚Üí${row[t][0].join(" ")}` : ""}</span>
                              </td>
                            ))}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              {results.isValid && results.action && (
                <div className="bg-white rounded-2xl p-6 border-2 border-blue-200 shadow-lg overflow-x-auto">
                  <h3 className="text-xl font-bold text-blue-900 mb-4">Tabla de An√°lisis SLR(1)</h3>
                  <div className="overflow-x-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="border-b-2 border-blue-300">
                          <th className="p-2 text-blue-700 font-semibold">Estado</th>
                          <th colSpan={results.terminals.length} className="p-2 text-blue-700 font-semibold border-x-2 border-blue-300">Action</th>
                          <th colSpan={results.nonTerminals.length} className="p-2 text-blue-700 font-semibold">Goto</th>
                        </tr>
                        <tr className="border-b-2 border-blue-300">
                          <th className="p-2"></th>
                          {results.terminals.map((t) => (<th key={t} className="p-2 text-blue-700">{t}</th>))}
                          {results.nonTerminals.map((nt) => (<th key={nt} className="p-2 text-blue-700">{nt}</th>))}
                        </tr>
                      </thead>
                      <tbody>
                        {Object.keys(results.action).map((state) => (
                          <tr key={state} className="border-b border-blue-200">
                            <td className="p-2 text-blue-900 font-semibold">{state}</td>
                            {results.terminals.map((t) => (<td key={t} className="p-2 text-center text-blue-600">{results.action[state][t] && results.action[state][t].length > 0 ? results.action[state][t][0] : ""}</td>))}
                            {results.nonTerminals.map((nt) => (<td key={nt} className="p-2 text-center text-blue-600">{results.gotoTable[state][nt] !== null ? results.gotoTable[state][nt] : ""}</td>))}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              {results.parseResult && (
                <div className="bg-white rounded-2xl p-6 border-2 border-blue-200 shadow-lg">
                  <h3 className="text-xl font-bold text-blue-900 mb-4 flex items-center gap-2">
                    {results.parseResult.success ? (<><CheckCircle className="text-green-600" size={24} />Cadena Aceptada</>) : (<><AlertCircle className="text-red-500" size={24} />Cadena Rechazada</>)}
                  </h3>

                  {results.parseResult.error && (<div className="mb-4 p-3 bg-red-50 border-2 border-red-300 rounded-lg"><p className="text-red-700">{results.parseResult.error}</p></div>)}

                  <div className="overflow-x-auto">
                    <table className="w-full text-sm">
                      <thead>
                        <tr className="border-b-2 border-blue-300">
                          <th className="p-3 text-blue-700 font-semibold text-left">Paso</th>
                          <th className="p-3 text-blue-700 font-semibold text-left">Pila</th>
                          <th className="p-3 text-blue-700 font-semibold text-left">Entrada</th>
                          <th className="p-3 text-blue-700 font-semibold text-left">Acci√≥n</th>
                        </tr>
                      </thead>
                      <tbody>
                        {results.parseResult.steps.map((step, idx) => (
                          <tr key={idx} className="border-b border-blue-200 hover:bg-blue-50">
                            <td className="p-3 text-blue-600 font-mono">{idx + 1}</td>
                            <td className="p-3 text-blue-900 font-mono">{step.stack}</td>
                            <td className="p-3 text-blue-900 font-mono">{step.input}</td>
                            <td className="p-3 text-green-600 font-semibold">{step.action}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    );
  }

  // Mount the app
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<ParserAnalyzer />);

  </script>
</body>
</html>
